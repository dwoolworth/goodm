package goodm

import (
	"bytes"
	"go/format"
	"strings"
	"text/template"

	"github.com/dwoolworth/goodm/internal"
)

// GenerateOptions controls code generation output.
type GenerateOptions struct {
	PackageName string // Go package name (default "models")
	OutputDir   string // where to write files
	EmbedModel  bool   // embed goodm.Model (default true)
}

// modelTemplateData is the data passed to the code generation template.
type modelTemplateData struct {
	Package        string
	StructName     string
	CollectionName string
	EmbedModel     bool
	Fields         []templateField
	CompoundIndexes []templateCompoundIndex
	NeedsTime      bool
	NeedsBSON      bool
	NeedsGoodm     bool
}

type templateField struct {
	GoName   string
	GoType   string
	BSONName string
	GoodmTag string
}

type templateCompoundIndex struct {
	Fields []string
	Unique bool
}

func joinFields(fields []string) string {
	quoted := make([]string, len(fields))
	for i, f := range fields {
		quoted[i] = `"` + f + `"`
	}
	return strings.Join(quoted, ", ")
}

var modelTmpl = template.Must(template.New("model").Funcs(template.FuncMap{
	"joinFields": joinFields,
}).Parse(`package {{ .Package }}

import (
	"log"
{{- if .NeedsTime }}
	"time"
{{- end }}
{{- if .NeedsBSON }}
	"go.mongodb.org/mongo-driver/v2/bson"
{{- end }}
{{- if .NeedsGoodm }}
	"github.com/dwoolworth/goodm"
{{- end }}
)

// {{ .StructName }} was generated by goodm discover from the "{{ .CollectionName }}" collection.
type {{ .StructName }} struct {
{{- if .EmbedModel }}
	goodm.Model ` + "`" + `bson:",inline"` + "`" + `
{{- end }}
{{- range .Fields }}
	{{ .GoName }}	{{ .GoType }}	` + "`" + `bson:"{{ .BSONName }}"{{ if .GoodmTag }} goodm:"{{ .GoodmTag }}"{{ end }}` + "`" + `
{{- end }}
}
{{ if .CompoundIndexes }}
// Indexes returns compound indexes for the {{ .StructName }} model.
func (m *{{ .StructName }}) Indexes() []goodm.CompoundIndex {
	return []goodm.CompoundIndex{
{{- range .CompoundIndexes }}
{{- if .Unique }}
		goodm.NewUniqueCompoundIndex({{ joinFields .Fields }}),
{{- else }}
		goodm.NewCompoundIndex({{ joinFields .Fields }}),
{{- end }}
{{- end }}
	}
}
{{ end }}
func init() {
	if err := goodm.Register(&{{ .StructName }}{}, "{{ .CollectionName }}"); err != nil {
		log.Fatalf("goodm: failed to register {{ .StructName }}: %v", err)
	}
}
`))

// GenerateModel generates Go source code for a discovered collection.
func GenerateModel(coll DiscoveredCollection, opts GenerateOptions) ([]byte, error) {
	if opts.PackageName == "" {
		opts.PackageName = "models"
	}

	structName := internal.SanitizeStructName(coll.Name)

	// Skip _id field if embedding Model (it provides _id)
	var fields []templateField
	needsTime := false
	needsBSON := false

	for _, f := range coll.Fields {
		if opts.EmbedModel && (f.BSONName == "_id" || f.BSONName == "created_at" || f.BSONName == "updated_at") {
			continue
		}

		goName := internal.ToExportedName(f.BSONName)
		goodmTag := internal.FormatGoodmTag(f.IsUnique, f.IsIndexed, f.IsRequired)

		if strings.Contains(f.GoType, "time.Time") {
			needsTime = true
		}
		if strings.Contains(f.GoType, "bson.") {
			needsBSON = true
		}

		fields = append(fields, templateField{
			GoName:   goName,
			GoType:   f.GoType,
			BSONName: f.BSONName,
			GoodmTag: goodmTag,
		})
	}

	// Collect compound indexes (multi-key only; single-key are tags)
	var compoundIndexes []templateCompoundIndex
	for _, idx := range coll.Indexes {
		if len(idx.Keys) > 1 {
			compoundIndexes = append(compoundIndexes, templateCompoundIndex{
				Fields: idx.Keys,
				Unique: idx.Unique,
			})
		}
	}

	data := modelTemplateData{
		Package:         opts.PackageName,
		StructName:      structName,
		CollectionName:  coll.Name,
		EmbedModel:      opts.EmbedModel,
		Fields:          fields,
		CompoundIndexes: compoundIndexes,
		NeedsTime:       needsTime,
		NeedsBSON:       needsBSON,
		NeedsGoodm:      opts.EmbedModel || len(compoundIndexes) > 0,
	}

	var buf bytes.Buffer
	if err := modelTmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	// Format with gofmt
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails (helpful for debugging)
		return buf.Bytes(), nil
	}

	return formatted, nil
}
